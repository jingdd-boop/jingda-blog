 # 作用域和闭包

 # 有关作用域
 ## 1.什么是作用域？
 书上描述作用域是一种规则。

 几乎所有的编程语言都具备一种能力，也就是能够存储变量当中的值，并且能在之后对其进行访问和更改，但是这些变量是存储在哪里？并且之后程序又是如何找到它们？ 这个如何存储决定了之后程序会以哪种规则去找到这个变量，而这种规则就是`作用域`。

 所以下面就来看下程序源代码在执行前，会对变量在哪里存储，以及如何进行存储（也就是如何制定某个变量得作用域）

 ### 1.1. 了解编译原理

传统编译语言，在程序中的一段源代码执行前会经历三个步骤，统称为“编译”

 ![截屏](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/271f4448ee93474da9a69de73ff80873~tplv-k3u1fbpfcp-watermark.image?)

> 这里讨论javascript，javascript引擎进行编译的步骤和传统的编译语言是很相似的，但是在有些地方可能要复杂的多，比如词法分析和代码生成阶段由特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等

接着详细介绍下上面的三个步骤
```js
var a = 2;
```
- 分词/词法分析
在这个阶段会将字符组成的字符串分解成有意义的代码快，这些代码快会被成为词法单元（token）。像`var a = 2;`。这段程序会被分解成
`var、 a、=、2、; ` (空格取决于在语言中是否起到作用)

- 解析/语法分析 parsing
这个过程是将词法单元流（是个数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。（抽象语法树 AST）

tokens[数组]

```js
[
    {
        "type": "Keyword",
        "value": "var"
    },
    {
        "type": "Identifier",
        "value": "a"
    },
    {
        "type": "Punctuator",
        "value": "="
    },
    {
        "type": "Numeric",
        "value": "2"
    },
    {
        "type": "Punctuator",
        "value": ";"
    }
]
```

AST [转换成对象更清楚些]
```js
{
  "type": "Program",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "a"
          },
          "init": {
            "type": "Literal",
            "value": 2,
            "raw": "2"
          }
        }
      ],
      "kind": "var"
    }
  ],
  "sourceType": "script"
}
```

- 代码生成
将AST转换成可执行的代码得过程叫做代码生成

将`var a = 2;`的AST转化成一组机器指令，用来创建一个a的变量，并为它分配内存，最后将一个值也就是2，存到a中。

### 1.2. 理解作用域
上面我们了解了编译语言在执行前会有的三个步骤，但是一直没说到作用域那块。最开始说的在哪里存储，如何存储，如何查找，现在让我们来了解一下作用域吧。

首先了解下几个重要的组成部分：

- 引擎
复杂javascript程序的编译和执行过程
- 编译器
负责编译前的准备工作，也就是前面说的`编译`流程
- 作用域
负责收集并维护由所以声明的标志符（变量）组成的一系列查找，并执行非常严重的规则---去确定当前执行的代码对这些标志符（变量）的访问权限。


再次拿下面这句代码作为例子
```js
var a = 2;
```

当引擎看到这句代码时，它会认为这句代码是有两个完全不一样的声明
-  一个是由编译器在编译时处理
-  一个则是由引擎自己处理

来看下具体协同流程：
1. 首先当然是编译器会将这段diam分解成词法单元，然后生成AST树结构。
2. 在生成代码得过程中，首先会遇到`var a`，如果已经由一个该名称的变量存在于同一个作用域集合中，那么编译器会忽略该声明，继续编译。如果没有声明，`那么它会要求在当前作用域的集合里面声明一个新的变量`，命名为a

3. 接着编译器将完成代码生成这一步骤，这些代码会被用来处理`a = 2`，也就是这个赋值的操作。
4. 最后交给引擎来执行，引擎首先也会查找，在当前作用域集合内是否存在一个叫a的变量，如果有，就使用。`如果没有就继续查找`  (这边是查找哦，那么如何查找呢？等会会说到)，如果最终找到了a变量，就为它赋值，否则就会抛出一个错误异常。


总结下：变量得赋值操作会有两步操作
- 编译器会在当前作用域中声明一个变量（存在就不用）
- 运行时引擎再去作用域中找，如果找到就赋值，没找到报错

### 1.3 引擎查找变量过程
上面说了，引擎在执行代码得时候，会去作用域里面查找看下是否有这个变量，如果没有它会继续查找，那么它是如何查找的呢？

查询分成两种，一种是LHS,一种的RHS，是一个赋值的左侧或者右侧。

当变量出现在赋值操作的左侧进行LHS查询，当变量出现在赋值操作的右侧的时候，就采用RHS查询。

更准确的说法：RHS查询与简单的查找某个变量得值是相似的，但是LHS是找到变量本身，从而对其赋值
```js
console.log(a) // 我们只是需要查找到a的值，而并非a的本身，因此用的LHS
```

```js
a = 2;  // 我们需要找到a的本身，并且为它赋值成2，因此用的就是LHS
```

### 1.4 作用域嵌套
刚才说到的，如果引擎没有在当前作用域下找到比那里，会继续往外面的作用域找，举个例子。

```js
function foo(a) {
    console.log(a + b);
}
var b = 3;
foo(2);
```

在函数foo的作用域中，对b进行RHS查询是找不到的，因此引擎会往外找，找到全局作用域`var b = 3`,找到了，就会拿去使用。

作用域的最外层是全局作用域，如果还没找到，就会报异常。


简单了解了一下变量赋值的一个流程，从`编译`阶段，到执行，到查找作用域中的变量，大致了解了一些。

# 理解不同类型的作用域 【1】
## 1. 词法作用域

之前我们有说到，在大部分的编译语言执行前会有一个“编译”的过程，里面的第一步叫做词法化，词法化阶段会对源代码中的字符串进行检查。而词法作用域就是定义在此法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的。，所以在词法分析器处理代码时会保持作用域不变（但并不是完全，在使用with和evel也会发生改变，之后再说到有关的欺骗词法）

```js
function foo(a) {
    var b = a * 2;

    function bar(c) {
        console.log(a,b,c);  // 如何找到这三个变量
    }

    bar(b * 3);
}

foo(2);
// 输出 2，4，12
```
首先在这个代码例子中有3个作用域
- 全局作用域 标志符 foo函数
- foo的作用域  标志符 a bar函数 b
- bar的作用域 标志符 c

```js
 console.log(a,b,c);
```
首先c所以bar的作用域里面，就直接拿就可以，b不属于bar的作用域，而是上一层foo函数的作用域，a也属于foo函数作用域里面。因此可以看到，查找作用域，是由内到外，首先找到最近的作用域，如果没找到，就继续往外查找。

而某个标志符的作用域是由它声明时候确定的（除了使用with，evel，但这两个通常不会被使用）


## 2. 函数作用域
### 2.1. 了解函数作用域
首先来看下一段代码

```js
function foo(a) {
    var b = 2;
        ...
    function bar () {
        ...
    }
        ...
    var c = 3;
}
```

在这段代码中，foo函数的作用域保护了标志符a，b，c和bar。无聊标志符声明出现在作用域中的何处，这个标志符所代表的变量或者函数都将属于所处的作用域。

bar函数拥有自己的作用域，全局作用域也拥有自己的作用域，而且它只有一个标志符foo

由于标志符a，b，c，foo和bar 在foo那边都是可以被访问的，因此无法从外部对它们进行访问。这些标志符是不能从全局作用域中进行访问。

比如：
```js
bar() // 报错

console.log(a,b,c); // 报错
```



但是，这些标志符a，b，c，foo和bar，在foo的内部都是可以被访问到的，同样在bar内部也可以被访问到

我的理解其实是，作用域查找只能由内到外，不能由外到内。

`所以再来看什么是函数作用域呢：属于这个函数的全部变量都可以在整个函数范围内被使用或者复用（在嵌套函数里面也可以）`

#### 2.2. 函数作用域封装变量和函数

##### 2.2.1 私有化，避免被更改

在代码块的周围创建作用域，也就是说这段代码中的任何声明都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域。
`可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来封装它们（隐藏）`

为什么要进行封装呢？
- 封装一个api或者方法，会让代码更加简洁
- 如果所有的代码都放在全局作用域，在局部作用域我们当然可以访问得到，但是有些变量我们可能并不希望它被其他地方使用，这样的我们需要将它`特殊化`。举例：
```js
function foo1(a) {
    b = a + foo2(a * 2);
    console.log(b * 3);
}

function foo2(a) {
    return a - 1;
}

var b;

foo1(2);
```

在函数foo1中，b和foo2是内部具体的内容，本应该不放到外部，如果放外部可能会被其他地方用到。


当我们将b和foo2封装到foo1函数里面去，那么外面的就不能用到它们啦，保证了一个私有性。
```js
function foo1(a) {
    function foo2(a) {
      return a - 1;
    }

    var b;

    b = a + foo2(a * 2);
    console.log(b * 3);
}
foo1(2);
```



##### 2.2.2 规避冲突

将变量和函数进行作用域封装还有一个好处是，可以避免同名标志符之间的冲突，两个标志符也许会出现相同的命名，但是用途不一样，会造成同名覆盖。

```js
function foo () {
    function bar (a) {
        i = 3;  // 每次执行bar，i都被设为3，永远满足小于10这个条件
        console.log(a + 1);
    }

    for (var i = 0;i < 10;i++) {
        bar (i * 2); // 循环了。。
    }
}

foo();
```

改成下面这样就可以
```js
function bar (a) {
    var i = 3;  // 每次执行bar，i都被设为3，永远满足小于10这个条件
        console.log(a + i);
    }
```


#### 函数作用域
在变量或者函数外部加作用域，外部就无法访问到作用域里面的标志符。

```js
var a = 2;

function foo () {
    var a = 3;
    console.log(a);
}

foo();
console.log(a); // 2
```

但这个方法也会有一些问题，首先因为我们需要创建一个作用域是个具名函数foo，这个foo的名称本身是在全局作用域中，其次，必须要显示的通过foo（）调用，才能运行当中的代码，如果不需要函数名，并且可以自动运行，会更好。


采用立即执行函数：

```js
var a = 2;

(function foo () {
    var a = 3;
    console.log(a);
})()

console.log(a); // 2
```

包装函数的声明以`（function`开始 而不是以`function...`，函数会被当作函数表达式而不是一个标准的函数声明来处理。

函数声明和函数表达式直接的区别：

- 第一段代码，函数声明：foo被绑定在所处的作用域中，可以通过foo（）来调用执行

- 第二段代码，函数表达式：foo被绑定在函数表达式自身的函数中而不是所在的作用域中

`（function foo() {..}）`作为函数表达式意味着foo只能在...所代表的位置中被访问，外部作用域则是访问不到的。

foo变量名被隐藏在自身的作用域中，意味着不会非必要的污染外部作用域。


# 块级作用域
## 1. 了解块级作用域
函数作用域是作用域中最常见的，但是其他类型的作用域也是存在的，比如块级作用域。


先来看一个for循环：
```js
for (var i=0;i < 10;i++) {
    console.log(i);
}
```
上面这个例子在for循环的头部定义了变量i，通常是因为只想在for循环内部的上下文中使用i，而忽略了i会被绑定在外部作用域（也就是全局作用域或者函数作用域）中的事实。

再看一个例子：
```js
var foo = true;

if (foo) {
    var bar = foo * 2;
    bar = something(bar);
    console.log(bar);
}
```

bar变量只在if声明的上下文中使用，因此如果能够将它声明在if'块内部中会是一个很有意义的事情，但是，当使用var声明变量的时候，写在哪里都是一样的，因为它们最终都会属于外部作用域。

> 块级作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码在函数中隐藏信息扩展为在块中隐藏信息。


## 2. let

es6 引入了let关键字，提供了除var以外的另一种变量声明方式。

let关键字可以将变量绑定到所在的任意作用域中（{}）,也就是说，let为其声明的变量隐式地劫持了所在的作用域。

```js
var foo = true;

if (foo) {
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
}

console.log(bar) // referenceError
```

使用let声明的变量不会在作用域中进行提升。声明的代码在运行前，声明并不“存在”。

```js
{
    console.log(a); // referenceError
    let a = 2;
}
```

### 2.1. let-垃圾回收
涉及闭包和垃圾回收机制的原理。
### 2.2. let-循环
```js
for (let i=0;i < 10;i++) {
    console.log(i);
}

console.log(i);// referenceError
```
for循环中的let不仅仅将i绑定到了for循环的块中，并且它将其重新绑定到了循环的每一次迭代中，确保使用上一次循环迭代结束时的值重新赋值。

## const

es6 同时引入了const关键字，用来创建常量，如果创建完之后修改值会报错。

```js
var foo = true;

if (foo) {
    var a = 2;
    const b = 7;

    a = 8; // 不报错
    b = 9; // 报错
}

console.log(a); // 8
console.log(b); // referenceError
```

# 提升

## 变量提升
 之前以及了解了有关作用域的相关概念，包括根据声明的位置和方式将变量分配给作用域，函数作用域和块作用域的行为是一样的。可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。

 我们可能回以为javascript代码是由上到下一行一行执行的。但实际上其实不是这样的：

 举例：

 第一段代码：
 ```js
 a = 2;
 var a;
 console.log(a); // 2
 ```
 会被编译成：
 ```js
 var a;
 a = 2;
 console.log(a); // 2
 ```


第二段代码：
 ```js
 console.log(a); // undefined

 var a = 2;
 ```
会被编译成：
 ```js
 var a;
 console.log(a);  // undefined
 a = 2;
```

可以看到声明var a；的代码会被提升到代码块的最前面。

并且，只有声明本身会被提升，而赋值或者其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成严重的破坏。

## 函数提升
```js
foo();

function foo() {
    console.log(a); // undefined
    var a = 2;
}
```

被编译成这样：
```js
function foo() {
    var a；
    console.log(a); // undefined
    a = 2;
}
foo();
```

> 每个作用域会有提升的操作，foo函数自身也会在代码内部对vara进行提升

上面是函数声明，会被提升。但是函数表达式不会被提升。

```js
foo(); // typeError

var foo = function bar() {
    //...
}
```

## 函数先于变量提升
前面我们可以看到，函数声明和变量声明都会有一个提升的操作，但是函数的声明会优先于变量的声明。
```js
foo();

var foo;

function foo() {
    console.log(1);
}

foo = function() {
    console.log(2);
}
```
最后输出1；

引擎解析代码的时候：
```js
function foo() {
    console.log(1);
}
foo(); // 1

var foo;

foo = function() {
  console.log(2);
}
```

var foo尽管出现在function foo() 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前

尽管重复的var声明会被忽略掉，但出现在后面的函数声明还是会覆盖前面的
```js
foo(); // 1 但是3会覆盖 所以最后输出的是3.

function foo() {
    console.log(1);
}

var foo = function() {
    console.log(2);
}

function foo() {
    console.log(3);
}
```
# 作用域闭包

## 什么是闭包？
当函数可以记住并访问所在的词法作用域时，就产生了闭包
函数；记住并访问；词法作用域

```js
function foo() {
    var a = 2;

    function bar() {
        console.log(a);
    }

    bar();
}

foo();
```

```js
function foo() {
    var a = 2;

    function bar() {
        console.log(a);
    }

    return bar();
}

var baz = foo();

baz(); // 2;
```

1. 函数bar()的词法作用域能够访问foo()函数的词法作用域，这个是没问题的。
2. 然后我们将bar()函数本身当作一个值类型进行传递，比如这个例子中的函数对象本身
3. bar()可以被正常执行，但是在这个例子中，`它在自己定义的词法作用域以外的地方执行`
4. 在foo()执行完后，通常是要被销毁的，因为js引擎里面有垃圾回收机制用来释放不再使用的内存空间
5. 但是闭包，就是可以阻止foo()的作用域被销毁，事实上foo()的内部作用域依然存在，没有被回收
6. 因为bar()函数还在使用这个内部作用域
7. 因此foo()的作用域会一直存活，以供bar()在之后的任何时间使用。

`bar()依然保持对该作用域的引用，这个引用就叫作闭包`

这个函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。

使用传递参数的方式产生的闭包举例：
```js
function foo() {
    var a = 2;

    function baz() {
        console.log(a);
    }
    bar(baz);
}

function bar(fn) {
    fn();
}
```

把内部函数baz传递给bar，当调用这个内部函数的时候，它涵盖的foo()的作用域的闭包就可以看到了，因为它可以访问a


间接传递函数产生的闭包：
```js
var fn;
function foo() {
    var a = 2;

    function baz() {
        console.log(a);
    }
    fn = baz;
}

function bar(fn) {
    fn();
}

foo();
bar(); // 2;
```

无论通过哪种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用的引用，无论在何处执行这个函数都会使用闭包。

## 再次理解闭包

常见的闭包：
```js
function wait(message) {
    setTimeout( function timer() {
        console.log(message);
    },1000);
}

wait('hello,jingda');
```
1. 将一个内部函数timer传递给setTimeout，timer具有涵盖wait作用域的闭包，因此还保留对变量的引用。
2. wait执行1000毫秒之后，它的内部作用域并不会消失，timer函数依然会保有wait作用域的闭包
3. 在引擎的内部，内置函数setTimeout有一个对参数的音乐，这个参数加上为fn，引擎会调用这个函数，在这个例子就是内部的timer函数，而词法作用域在这个过程一直都是保持完整的。这个就是闭包。

> 本质上，如果将函数当作第一级的值类型到处传递，会看到闭包在这些函数中的应用。

在定时器，事件监听器，ajax请求，跨窗口通信，web workers，或者其他异步同步的任务中，只要使用了回调函数，实际上就是在使用闭包。

## 循环和闭包

```js
for(var i = 1;i <= 5;i++) {
    setTimeout( function timer() {
        console.log(i);
    },i * 1000);
}
```
结果是：每秒一次输出五次6；

1. 首先是为什么输出6，这个循环的终止条件是i>5,条件成立的第一个值就是6
2. 输出显示的是循环结束时的最终值。
3. `延迟函数的回调会在循环介绍时才执行。`
4. 循环的五个函数在各个迭代中是分别定义的，但是他们都封闭在了一个共享的全局作用域中，因此，只有一个i
5. 如果将延迟函数的回调重新定义5次，完全不使用循环，和这段代码是一样的效果。
6. 我们需要更多的作用域。

- 立即执行函数

下面这样直接加是不起作用的哦，还是一样的效果：
此时的立即执行函数作用域里面是空的，没有实质的变量。
```js
for(var i = 1;i <= 5;i++) {
    (function () {
      setTimeout( function timer() {
        console.log(i);
      },i * 1000);
    })();
}
```

立即执行函数，需要有自己的变量去存储i的值：
```js
for(var i = 1;i <= 5;i++) {
    (function (j) {
      setTimeout( function timer() {
        console.log(j);
      },j * 1000);
    })(i);
}
```

## 闭包和块作用域

```js
for(var i = 1;i <= 5;i++) {
    let j = i;
    setTimeout( function timer() {
        console.log(j);
    },j * 1000);
}
```

```js
for(let i = 1;i <= 5;i++) {
    setTimeout( function timer() {
        console.log(i);
    },i * 1000);
}
```

`当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包`；